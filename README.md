# java-completable-future-tasks

## Мета

[cite_start]Цей проєкт був розроблений для поглибленого вивчення та демонстрації **асинхронного програмування** в Java за допомогою потужного API **`CompletableFuture`**[cite: 143]. [cite_start]Основна мета — показати, як створювати, з'єднувати (chaining) та керувати неблокуючими, залежними обчислювальними операціями[cite: 123, 128].

### Основні Концепції

| Концепція | Опис |
| :--- | :--- |
| **CompletableFuture** | [cite_start]Клас, який усуває недоліки старого `Future` API та підтримує ланцюжки обчислень[cite: 123]. [cite_start]Реалізує інтерфейси `Future<T>` та `CompletionStage<T>`[cite: 61]. |
| **Асинхронні ланцюжки** | [cite_start]Можливість комбінувати кілька асинхронних завдань, відкриваючи шлях до побудови складних сценаріїв паралельних обчислень[cite: 128]. |
| **Функціональні Інтерфейси** | [cite_start]Використання інтерфейсів, таких як `Supplier<T>`, `Function<T, R>`, та `Consumer<T>`, що роблять роботу з `CompletableFuture` гнучкою[cite: 125, 49, 44, 39]. |
| **ForkJoinPool** | [cite_start]За замовчуванням, асинхронні методи (`somethingAsync()`) виконують дії у спільному пулі потоків **`ForkJoinPool.commonPool()`**[cite: 80, 82]. |

---

## Використані Методи CompletableFuture

У проєкті продемонстровано такі ключові методи:

| Метод | Інтерфейс | Призначення |
| :--- | :--- | :--- |
| **`supplyAsync()`** | `Supplier<T>` | [cite_start]Запускає асинхронне завдання, яке **повертає результат**[cite: 135]. |
| **`runAsync()`** | `Runnable` | [cite_start]Запускає асинхронне завдання, яке **не повертає результат**[cite: 135]. |
| **`thenApplyAsync()`** | `Function<T, R>` | [cite_start]Ланцюжок, який приймає результат попереднього етапу та **застосовує трансформацію, повертаючи новий результат**[cite: 86, 136]. |
| **`thenAcceptAsync()`** | `Consumer<T>` | [cite_start]Ланцюжок, який приймає результат попереднього етапу та **виконує дію (споживає його), але не повертає значення**[cite: 87, 136]. |
| **`thenRunAsync()`** | `Runnable` | [cite_start]Ланцюжок, який виконує дію **після завершення** попереднього етапу, **не використовуючи його результат** і **не повертаючи значення**[cite: 88, 136]. |
| **`thenCompose()`** | N/A | Використовується для "зведення" (flat-mapping) двох залежних `CompletableFuture` об'єктів в один, уникаючи вкладеності. |

---

## Структура Проєкту

Проєкт розділено на два окремі пакети, кожен з яких містить незалежний головний клас з власним методом `main()` для демонстрації модульності та незалежного запуску завдань.

```

java-completable-future-tasks/
├── src/
│   ├── task1/
│   │   └── TaskOne.java            // Головний клас для Завдання 1.
│   └── task2/
│       └── TaskTwo.java            // Головний клас для Завдання 2.
└── README.md

````

---

## Опис Завдань та Реалізації

### Завдання 1: Ланцюжок Модифікації Масиву (`task1/TaskOne.java`)

Демонструє повний ланцюжок залежних асинхронних обчислень та трансформацій.

* **Генерація:** Створення масиву з 10 цілих чисел (`int[]`) за допомогою `supplyAsync()`.
* **Модифікація (+10):** Додавання `+10` до кожного елемента за допомогою `thenApplyAsync()`.
* **Модифікація (/2):** Ділення кожного елемента на `2.0`, що трансформує масив з `int[]` на `Double[]`, за допомогою `thenApplyAsync()`.
* **Виведення даних:** Виведення фінального результату з інформаційним текстом за допомогою `thenAcceptAsync()`.
* **Фінальна дія:** Виведення загального часу виконання всіх асинхронних операцій за допомогою `thenRunAsync()`.

### Завдання 2: Обчислення Добутку Різниць (`task2/TaskTwo.java`)

Демонструє обчислювальний потік для складного математичного завдання.

* **Генерація послідовності:** Створення послідовності з 20 дійсних чисел (`double[]`) за допомогою `supplyAsync()`.
* **Обчислення:** Асинхронний розрахунок добутку різниць послідовних елементів: $(a_2 - a_1) \cdot (a_3 - a_2) \cdot \dots \cdot (a_n - a_{n-1})$ за допомогою `thenApplyAsync()`.
* **Виведення:** Виведення кінцевого результату та загального часу виконання всіх операцій за допомогою `thenAcceptAsync()`.

---

## Як Запустити

Для запуску кожного завдання окремо виконайте наступні кроки у вашому терміналі, починаючи з кореневої директорії проєкту:

### 1. Компіляція

Компіляція всіх класів у проєкті:

```bash
javac src/task1/TaskOne.java src/task2/TaskTwo.java
````

### 2\. Запуск Завдання 1

Запускається головний клас з пакета `task1`.

```bash
java src/task1/TaskOne
```

### 3\. Запуск Завдання 2

Запускається головний клас з пакета `task2`.

```bash
java src/task2/TaskTwo
```

*Консольний вивід кожного запуску буде відображати послідовність асинхронних етапів, потоки виконання (`ForkJoinPool.commonPool-worker-X`) та виміряний час виконання для кожного етапу.*

